// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	nats "github.com/nats-io/nats.go"
	mock "github.com/stretchr/testify/mock"
)

// JetStreamContextMock is an autogenerated mock type for the JetStreamContext type
type JetStreamContextMock struct {
	mock.Mock
}

type JetStreamContextMock_Expecter struct {
	mock *mock.Mock
}

func (_m *JetStreamContextMock) EXPECT() *JetStreamContextMock_Expecter {
	return &JetStreamContextMock_Expecter{mock: &_m.Mock}
}

// AccountInfo provides a mock function with given fields: opts
func (_m *JetStreamContextMock) AccountInfo(opts ...nats.JSOpt) (*nats.AccountInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.AccountInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) (*nats.AccountInfo, error)); ok {
		return rf(opts...)
	}
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) *nats.AccountInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.AccountInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(...nats.JSOpt) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_AccountInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountInfo'
type JetStreamContextMock_AccountInfo_Call struct {
	*mock.Call
}

// AccountInfo is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) AccountInfo(opts ...interface{}) *JetStreamContextMock_AccountInfo_Call {
	return &JetStreamContextMock_AccountInfo_Call{Call: _e.mock.On("AccountInfo",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_AccountInfo_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContextMock_AccountInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_AccountInfo_Call) Return(_a0 *nats.AccountInfo, _a1 error) *JetStreamContextMock_AccountInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_AccountInfo_Call) RunAndReturn(run func(...nats.JSOpt) (*nats.AccountInfo, error)) *JetStreamContextMock_AccountInfo_Call {
	_c.Call.Return(run)
	return _c
}

// AddConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamContextMock) AddConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_AddConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddConsumer'
type JetStreamContextMock_AddConsumer_Call struct {
	*mock.Call
}

// AddConsumer is a helper method to define mock.On call
//   - stream string
//   - cfg *nats.ConsumerConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) AddConsumer(stream interface{}, cfg interface{}, opts ...interface{}) *JetStreamContextMock_AddConsumer_Call {
	return &JetStreamContextMock_AddConsumer_Call{Call: _e.mock.On("AddConsumer",
		append([]interface{}{stream, cfg}, opts...)...)}
}

func (_c *JetStreamContextMock_AddConsumer_Call) Run(run func(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt)) *JetStreamContextMock_AddConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(*nats.ConsumerConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_AddConsumer_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContextMock_AddConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_AddConsumer_Call) RunAndReturn(run func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContextMock_AddConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// AddStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamContextMock) AddStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_AddStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddStream'
type JetStreamContextMock_AddStream_Call struct {
	*mock.Call
}

// AddStream is a helper method to define mock.On call
//   - cfg *nats.StreamConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) AddStream(cfg interface{}, opts ...interface{}) *JetStreamContextMock_AddStream_Call {
	return &JetStreamContextMock_AddStream_Call{Call: _e.mock.On("AddStream",
		append([]interface{}{cfg}, opts...)...)}
}

func (_c *JetStreamContextMock_AddStream_Call) Run(run func(cfg *nats.StreamConfig, opts ...nats.JSOpt)) *JetStreamContextMock_AddStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(*nats.StreamConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_AddStream_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContextMock_AddStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_AddStream_Call) RunAndReturn(run func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContextMock_AddStream_Call {
	_c.Call.Return(run)
	return _c
}

// ChanQueueSubscribe provides a mock function with given fields: subj, queue, ch, opts
func (_m *JetStreamContextMock) ChanQueueSubscribe(subj string, queue string, ch chan *nats.Msg, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue, ch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, ch, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, chan *nats.Msg, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, ch, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, chan *nats.Msg, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, ch, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_ChanQueueSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChanQueueSubscribe'
type JetStreamContextMock_ChanQueueSubscribe_Call struct {
	*mock.Call
}

// ChanQueueSubscribe is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - ch chan *nats.Msg
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) ChanQueueSubscribe(subj interface{}, queue interface{}, ch interface{}, opts ...interface{}) *JetStreamContextMock_ChanQueueSubscribe_Call {
	return &JetStreamContextMock_ChanQueueSubscribe_Call{Call: _e.mock.On("ChanQueueSubscribe",
		append([]interface{}{subj, queue, ch}, opts...)...)}
}

func (_c *JetStreamContextMock_ChanQueueSubscribe_Call) Run(run func(subj string, queue string, ch chan *nats.Msg, opts ...nats.SubOpt)) *JetStreamContextMock_ChanQueueSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(chan *nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ChanQueueSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_ChanQueueSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_ChanQueueSubscribe_Call) RunAndReturn(run func(string, string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_ChanQueueSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// ChanSubscribe provides a mock function with given fields: subj, ch, opts
func (_m *JetStreamContextMock) ChanSubscribe(subj string, ch chan *nats.Msg, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, ch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, ch, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, chan *nats.Msg, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, ch, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, chan *nats.Msg, ...nats.SubOpt) error); ok {
		r1 = rf(subj, ch, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_ChanSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChanSubscribe'
type JetStreamContextMock_ChanSubscribe_Call struct {
	*mock.Call
}

// ChanSubscribe is a helper method to define mock.On call
//   - subj string
//   - ch chan *nats.Msg
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) ChanSubscribe(subj interface{}, ch interface{}, opts ...interface{}) *JetStreamContextMock_ChanSubscribe_Call {
	return &JetStreamContextMock_ChanSubscribe_Call{Call: _e.mock.On("ChanSubscribe",
		append([]interface{}{subj, ch}, opts...)...)}
}

func (_c *JetStreamContextMock_ChanSubscribe_Call) Run(run func(subj string, ch chan *nats.Msg, opts ...nats.SubOpt)) *JetStreamContextMock_ChanSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(chan *nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ChanSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_ChanSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_ChanSubscribe_Call) RunAndReturn(run func(string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_ChanSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumerInfo provides a mock function with given fields: stream, name, opts
func (_m *JetStreamContextMock) ConsumerInfo(stream string, name string, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, name, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, name, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_ConsumerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumerInfo'
type JetStreamContextMock_ConsumerInfo_Call struct {
	*mock.Call
}

// ConsumerInfo is a helper method to define mock.On call
//   - stream string
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) ConsumerInfo(stream interface{}, name interface{}, opts ...interface{}) *JetStreamContextMock_ConsumerInfo_Call {
	return &JetStreamContextMock_ConsumerInfo_Call{Call: _e.mock.On("ConsumerInfo",
		append([]interface{}{stream, name}, opts...)...)}
}

func (_c *JetStreamContextMock_ConsumerInfo_Call) Run(run func(stream string, name string, opts ...nats.JSOpt)) *JetStreamContextMock_ConsumerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ConsumerInfo_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContextMock_ConsumerInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_ConsumerInfo_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContextMock_ConsumerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumerNames provides a mock function with given fields: stream, opts
func (_m *JetStreamContextMock) ConsumerNames(stream string, opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan string); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContextMock_ConsumerNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumerNames'
type JetStreamContextMock_ConsumerNames_Call struct {
	*mock.Call
}

// ConsumerNames is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) ConsumerNames(stream interface{}, opts ...interface{}) *JetStreamContextMock_ConsumerNames_Call {
	return &JetStreamContextMock_ConsumerNames_Call{Call: _e.mock.On("ConsumerNames",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContextMock_ConsumerNames_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContextMock_ConsumerNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ConsumerNames_Call) Return(_a0 <-chan string) *JetStreamContextMock_ConsumerNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_ConsumerNames_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan string) *JetStreamContextMock_ConsumerNames_Call {
	_c.Call.Return(run)
	return _c
}

// Consumers provides a mock function with given fields: stream, opts
func (_m *JetStreamContextMock) Consumers(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.ConsumerInfo)
		}
	}

	return r0
}

// JetStreamContextMock_Consumers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consumers'
type JetStreamContextMock_Consumers_Call struct {
	*mock.Call
}

// Consumers is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) Consumers(stream interface{}, opts ...interface{}) *JetStreamContextMock_Consumers_Call {
	return &JetStreamContextMock_Consumers_Call{Call: _e.mock.On("Consumers",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContextMock_Consumers_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContextMock_Consumers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_Consumers_Call) Return(_a0 <-chan *nats.ConsumerInfo) *JetStreamContextMock_Consumers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_Consumers_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo) *JetStreamContextMock_Consumers_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumersInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamContextMock) ConsumersInfo(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.ConsumerInfo)
		}
	}

	return r0
}

// JetStreamContextMock_ConsumersInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumersInfo'
type JetStreamContextMock_ConsumersInfo_Call struct {
	*mock.Call
}

// ConsumersInfo is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) ConsumersInfo(stream interface{}, opts ...interface{}) *JetStreamContextMock_ConsumersInfo_Call {
	return &JetStreamContextMock_ConsumersInfo_Call{Call: _e.mock.On("ConsumersInfo",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContextMock_ConsumersInfo_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContextMock_ConsumersInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ConsumersInfo_Call) Return(_a0 <-chan *nats.ConsumerInfo) *JetStreamContextMock_ConsumersInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_ConsumersInfo_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo) *JetStreamContextMock_ConsumersInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKeyValue provides a mock function with given fields: cfg
func (_m *JetStreamContextMock) CreateKeyValue(cfg *nats.KeyValueConfig) (nats.KeyValue, error) {
	ret := _m.Called(cfg)

	var r0 nats.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.KeyValueConfig) (nats.KeyValue, error)); ok {
		return rf(cfg)
	}
	if rf, ok := ret.Get(0).(func(*nats.KeyValueConfig) nats.KeyValue); ok {
		r0 = rf(cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.KeyValueConfig) error); ok {
		r1 = rf(cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_CreateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKeyValue'
type JetStreamContextMock_CreateKeyValue_Call struct {
	*mock.Call
}

// CreateKeyValue is a helper method to define mock.On call
//   - cfg *nats.KeyValueConfig
func (_e *JetStreamContextMock_Expecter) CreateKeyValue(cfg interface{}) *JetStreamContextMock_CreateKeyValue_Call {
	return &JetStreamContextMock_CreateKeyValue_Call{Call: _e.mock.On("CreateKeyValue", cfg)}
}

func (_c *JetStreamContextMock_CreateKeyValue_Call) Run(run func(cfg *nats.KeyValueConfig)) *JetStreamContextMock_CreateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*nats.KeyValueConfig))
	})
	return _c
}

func (_c *JetStreamContextMock_CreateKeyValue_Call) Return(_a0 nats.KeyValue, _a1 error) *JetStreamContextMock_CreateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_CreateKeyValue_Call) RunAndReturn(run func(*nats.KeyValueConfig) (nats.KeyValue, error)) *JetStreamContextMock_CreateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateObjectStore provides a mock function with given fields: cfg
func (_m *JetStreamContextMock) CreateObjectStore(cfg *nats.ObjectStoreConfig) (nats.ObjectStore, error) {
	ret := _m.Called(cfg)

	var r0 nats.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.ObjectStoreConfig) (nats.ObjectStore, error)); ok {
		return rf(cfg)
	}
	if rf, ok := ret.Get(0).(func(*nats.ObjectStoreConfig) nats.ObjectStore); ok {
		r0 = rf(cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.ObjectStoreConfig) error); ok {
		r1 = rf(cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_CreateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateObjectStore'
type JetStreamContextMock_CreateObjectStore_Call struct {
	*mock.Call
}

// CreateObjectStore is a helper method to define mock.On call
//   - cfg *nats.ObjectStoreConfig
func (_e *JetStreamContextMock_Expecter) CreateObjectStore(cfg interface{}) *JetStreamContextMock_CreateObjectStore_Call {
	return &JetStreamContextMock_CreateObjectStore_Call{Call: _e.mock.On("CreateObjectStore", cfg)}
}

func (_c *JetStreamContextMock_CreateObjectStore_Call) Run(run func(cfg *nats.ObjectStoreConfig)) *JetStreamContextMock_CreateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*nats.ObjectStoreConfig))
	})
	return _c
}

func (_c *JetStreamContextMock_CreateObjectStore_Call) Return(_a0 nats.ObjectStore, _a1 error) *JetStreamContextMock_CreateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_CreateObjectStore_Call) RunAndReturn(run func(*nats.ObjectStoreConfig) (nats.ObjectStore, error)) *JetStreamContextMock_CreateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConsumer provides a mock function with given fields: stream, consumer, opts
func (_m *JetStreamContextMock) DeleteConsumer(stream string, consumer string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, consumer)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) error); ok {
		r0 = rf(stream, consumer, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_DeleteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConsumer'
type JetStreamContextMock_DeleteConsumer_Call struct {
	*mock.Call
}

// DeleteConsumer is a helper method to define mock.On call
//   - stream string
//   - consumer string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) DeleteConsumer(stream interface{}, consumer interface{}, opts ...interface{}) *JetStreamContextMock_DeleteConsumer_Call {
	return &JetStreamContextMock_DeleteConsumer_Call{Call: _e.mock.On("DeleteConsumer",
		append([]interface{}{stream, consumer}, opts...)...)}
}

func (_c *JetStreamContextMock_DeleteConsumer_Call) Run(run func(stream string, consumer string, opts ...nats.JSOpt)) *JetStreamContextMock_DeleteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_DeleteConsumer_Call) Return(_a0 error) *JetStreamContextMock_DeleteConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_DeleteConsumer_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) error) *JetStreamContextMock_DeleteConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKeyValue provides a mock function with given fields: bucket
func (_m *JetStreamContextMock) DeleteKeyValue(bucket string) error {
	ret := _m.Called(bucket)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_DeleteKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKeyValue'
type JetStreamContextMock_DeleteKeyValue_Call struct {
	*mock.Call
}

// DeleteKeyValue is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContextMock_Expecter) DeleteKeyValue(bucket interface{}) *JetStreamContextMock_DeleteKeyValue_Call {
	return &JetStreamContextMock_DeleteKeyValue_Call{Call: _e.mock.On("DeleteKeyValue", bucket)}
}

func (_c *JetStreamContextMock_DeleteKeyValue_Call) Run(run func(bucket string)) *JetStreamContextMock_DeleteKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContextMock_DeleteKeyValue_Call) Return(_a0 error) *JetStreamContextMock_DeleteKeyValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_DeleteKeyValue_Call) RunAndReturn(run func(string) error) *JetStreamContextMock_DeleteKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContextMock) DeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_DeleteMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMsg'
type JetStreamContextMock_DeleteMsg_Call struct {
	*mock.Call
}

// DeleteMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) DeleteMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContextMock_DeleteMsg_Call {
	return &JetStreamContextMock_DeleteMsg_Call{Call: _e.mock.On("DeleteMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContextMock_DeleteMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContextMock_DeleteMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_DeleteMsg_Call) Return(_a0 error) *JetStreamContextMock_DeleteMsg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_DeleteMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) error) *JetStreamContextMock_DeleteMsg_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectStore provides a mock function with given fields: bucket
func (_m *JetStreamContextMock) DeleteObjectStore(bucket string) error {
	ret := _m.Called(bucket)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_DeleteObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectStore'
type JetStreamContextMock_DeleteObjectStore_Call struct {
	*mock.Call
}

// DeleteObjectStore is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContextMock_Expecter) DeleteObjectStore(bucket interface{}) *JetStreamContextMock_DeleteObjectStore_Call {
	return &JetStreamContextMock_DeleteObjectStore_Call{Call: _e.mock.On("DeleteObjectStore", bucket)}
}

func (_c *JetStreamContextMock_DeleteObjectStore_Call) Run(run func(bucket string)) *JetStreamContextMock_DeleteObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContextMock_DeleteObjectStore_Call) Return(_a0 error) *JetStreamContextMock_DeleteObjectStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_DeleteObjectStore_Call) RunAndReturn(run func(string) error) *JetStreamContextMock_DeleteObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStream provides a mock function with given fields: name, opts
func (_m *JetStreamContextMock) DeleteStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_DeleteStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStream'
type JetStreamContextMock_DeleteStream_Call struct {
	*mock.Call
}

// DeleteStream is a helper method to define mock.On call
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) DeleteStream(name interface{}, opts ...interface{}) *JetStreamContextMock_DeleteStream_Call {
	return &JetStreamContextMock_DeleteStream_Call{Call: _e.mock.On("DeleteStream",
		append([]interface{}{name}, opts...)...)}
}

func (_c *JetStreamContextMock_DeleteStream_Call) Run(run func(name string, opts ...nats.JSOpt)) *JetStreamContextMock_DeleteStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_DeleteStream_Call) Return(_a0 error) *JetStreamContextMock_DeleteStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_DeleteStream_Call) RunAndReturn(run func(string, ...nats.JSOpt) error) *JetStreamContextMock_DeleteStream_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastMsg provides a mock function with given fields: name, subject, opts
func (_m *JetStreamContextMock) GetLastMsg(name string, subject string, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, subject)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) (*nats.RawStreamMsg, error)); ok {
		return rf(name, subject, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, subject, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(name, subject, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_GetLastMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastMsg'
type JetStreamContextMock_GetLastMsg_Call struct {
	*mock.Call
}

// GetLastMsg is a helper method to define mock.On call
//   - name string
//   - subject string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) GetLastMsg(name interface{}, subject interface{}, opts ...interface{}) *JetStreamContextMock_GetLastMsg_Call {
	return &JetStreamContextMock_GetLastMsg_Call{Call: _e.mock.On("GetLastMsg",
		append([]interface{}{name, subject}, opts...)...)}
}

func (_c *JetStreamContextMock_GetLastMsg_Call) Run(run func(name string, subject string, opts ...nats.JSOpt)) *JetStreamContextMock_GetLastMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_GetLastMsg_Call) Return(_a0 *nats.RawStreamMsg, _a1 error) *JetStreamContextMock_GetLastMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_GetLastMsg_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) (*nats.RawStreamMsg, error)) *JetStreamContextMock_GetLastMsg_Call {
	_c.Call.Return(run)
	return _c
}

// GetMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContextMock) GetMsg(name string, seq uint64, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) (*nats.RawStreamMsg, error)); ok {
		return rf(name, seq, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, seq, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint64, ...nats.JSOpt) error); ok {
		r1 = rf(name, seq, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_GetMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMsg'
type JetStreamContextMock_GetMsg_Call struct {
	*mock.Call
}

// GetMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) GetMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContextMock_GetMsg_Call {
	return &JetStreamContextMock_GetMsg_Call{Call: _e.mock.On("GetMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContextMock_GetMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContextMock_GetMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_GetMsg_Call) Return(_a0 *nats.RawStreamMsg, _a1 error) *JetStreamContextMock_GetMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_GetMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) (*nats.RawStreamMsg, error)) *JetStreamContextMock_GetMsg_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValue provides a mock function with given fields: bucket
func (_m *JetStreamContextMock) KeyValue(bucket string) (nats.KeyValue, error) {
	ret := _m.Called(bucket)

	var r0 nats.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (nats.KeyValue, error)); ok {
		return rf(bucket)
	}
	if rf, ok := ret.Get(0).(func(string) nats.KeyValue); ok {
		r0 = rf(bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_KeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValue'
type JetStreamContextMock_KeyValue_Call struct {
	*mock.Call
}

// KeyValue is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContextMock_Expecter) KeyValue(bucket interface{}) *JetStreamContextMock_KeyValue_Call {
	return &JetStreamContextMock_KeyValue_Call{Call: _e.mock.On("KeyValue", bucket)}
}

func (_c *JetStreamContextMock_KeyValue_Call) Run(run func(bucket string)) *JetStreamContextMock_KeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContextMock_KeyValue_Call) Return(_a0 nats.KeyValue, _a1 error) *JetStreamContextMock_KeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_KeyValue_Call) RunAndReturn(run func(string) (nats.KeyValue, error)) *JetStreamContextMock_KeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStoreNames provides a mock function with given fields:
func (_m *JetStreamContextMock) KeyValueStoreNames() <-chan string {
	ret := _m.Called()

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func() <-chan string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContextMock_KeyValueStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStoreNames'
type JetStreamContextMock_KeyValueStoreNames_Call struct {
	*mock.Call
}

// KeyValueStoreNames is a helper method to define mock.On call
func (_e *JetStreamContextMock_Expecter) KeyValueStoreNames() *JetStreamContextMock_KeyValueStoreNames_Call {
	return &JetStreamContextMock_KeyValueStoreNames_Call{Call: _e.mock.On("KeyValueStoreNames")}
}

func (_c *JetStreamContextMock_KeyValueStoreNames_Call) Run(run func()) *JetStreamContextMock_KeyValueStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContextMock_KeyValueStoreNames_Call) Return(_a0 <-chan string) *JetStreamContextMock_KeyValueStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_KeyValueStoreNames_Call) RunAndReturn(run func() <-chan string) *JetStreamContextMock_KeyValueStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStores provides a mock function with given fields:
func (_m *JetStreamContextMock) KeyValueStores() <-chan nats.KeyValueStatus {
	ret := _m.Called()

	var r0 <-chan nats.KeyValueStatus
	if rf, ok := ret.Get(0).(func() <-chan nats.KeyValueStatus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan nats.KeyValueStatus)
		}
	}

	return r0
}

// JetStreamContextMock_KeyValueStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStores'
type JetStreamContextMock_KeyValueStores_Call struct {
	*mock.Call
}

// KeyValueStores is a helper method to define mock.On call
func (_e *JetStreamContextMock_Expecter) KeyValueStores() *JetStreamContextMock_KeyValueStores_Call {
	return &JetStreamContextMock_KeyValueStores_Call{Call: _e.mock.On("KeyValueStores")}
}

func (_c *JetStreamContextMock_KeyValueStores_Call) Run(run func()) *JetStreamContextMock_KeyValueStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContextMock_KeyValueStores_Call) Return(_a0 <-chan nats.KeyValueStatus) *JetStreamContextMock_KeyValueStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_KeyValueStores_Call) RunAndReturn(run func() <-chan nats.KeyValueStatus) *JetStreamContextMock_KeyValueStores_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStore provides a mock function with given fields: bucket
func (_m *JetStreamContextMock) ObjectStore(bucket string) (nats.ObjectStore, error) {
	ret := _m.Called(bucket)

	var r0 nats.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (nats.ObjectStore, error)); ok {
		return rf(bucket)
	}
	if rf, ok := ret.Get(0).(func(string) nats.ObjectStore); ok {
		r0 = rf(bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_ObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStore'
type JetStreamContextMock_ObjectStore_Call struct {
	*mock.Call
}

// ObjectStore is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContextMock_Expecter) ObjectStore(bucket interface{}) *JetStreamContextMock_ObjectStore_Call {
	return &JetStreamContextMock_ObjectStore_Call{Call: _e.mock.On("ObjectStore", bucket)}
}

func (_c *JetStreamContextMock_ObjectStore_Call) Run(run func(bucket string)) *JetStreamContextMock_ObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContextMock_ObjectStore_Call) Return(_a0 nats.ObjectStore, _a1 error) *JetStreamContextMock_ObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_ObjectStore_Call) RunAndReturn(run func(string) (nats.ObjectStore, error)) *JetStreamContextMock_ObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStoreNames provides a mock function with given fields: opts
func (_m *JetStreamContextMock) ObjectStoreNames(opts ...nats.ObjectOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(...nats.ObjectOpt) <-chan string); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContextMock_ObjectStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStoreNames'
type JetStreamContextMock_ObjectStoreNames_Call struct {
	*mock.Call
}

// ObjectStoreNames is a helper method to define mock.On call
//   - opts ...nats.ObjectOpt
func (_e *JetStreamContextMock_Expecter) ObjectStoreNames(opts ...interface{}) *JetStreamContextMock_ObjectStoreNames_Call {
	return &JetStreamContextMock_ObjectStoreNames_Call{Call: _e.mock.On("ObjectStoreNames",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_ObjectStoreNames_Call) Run(run func(opts ...nats.ObjectOpt)) *JetStreamContextMock_ObjectStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.ObjectOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.ObjectOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ObjectStoreNames_Call) Return(_a0 <-chan string) *JetStreamContextMock_ObjectStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_ObjectStoreNames_Call) RunAndReturn(run func(...nats.ObjectOpt) <-chan string) *JetStreamContextMock_ObjectStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStores provides a mock function with given fields: opts
func (_m *JetStreamContextMock) ObjectStores(opts ...nats.ObjectOpt) <-chan nats.ObjectStoreStatus {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan nats.ObjectStoreStatus
	if rf, ok := ret.Get(0).(func(...nats.ObjectOpt) <-chan nats.ObjectStoreStatus); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan nats.ObjectStoreStatus)
		}
	}

	return r0
}

// JetStreamContextMock_ObjectStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStores'
type JetStreamContextMock_ObjectStores_Call struct {
	*mock.Call
}

// ObjectStores is a helper method to define mock.On call
//   - opts ...nats.ObjectOpt
func (_e *JetStreamContextMock_Expecter) ObjectStores(opts ...interface{}) *JetStreamContextMock_ObjectStores_Call {
	return &JetStreamContextMock_ObjectStores_Call{Call: _e.mock.On("ObjectStores",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_ObjectStores_Call) Run(run func(opts ...nats.ObjectOpt)) *JetStreamContextMock_ObjectStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.ObjectOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.ObjectOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_ObjectStores_Call) Return(_a0 <-chan nats.ObjectStoreStatus) *JetStreamContextMock_ObjectStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_ObjectStores_Call) RunAndReturn(run func(...nats.ObjectOpt) <-chan nats.ObjectStoreStatus) *JetStreamContextMock_ObjectStores_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: subj, data, opts
func (_m *JetStreamContextMock) Publish(subj string, data []byte, opts ...nats.PubOpt) (*nats.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) (*nats.PubAck, error)); ok {
		return rf(subj, data, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) *nats.PubAck); ok {
		r0 = rf(subj, data, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...nats.PubOpt) error); ok {
		r1 = rf(subj, data, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type JetStreamContextMock_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - subj string
//   - data []byte
//   - opts ...nats.PubOpt
func (_e *JetStreamContextMock_Expecter) Publish(subj interface{}, data interface{}, opts ...interface{}) *JetStreamContextMock_Publish_Call {
	return &JetStreamContextMock_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{subj, data}, opts...)...)}
}

func (_c *JetStreamContextMock_Publish_Call) Run(run func(subj string, data []byte, opts ...nats.PubOpt)) *JetStreamContextMock_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_Publish_Call) Return(_a0 *nats.PubAck, _a1 error) *JetStreamContextMock_Publish_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_Publish_Call) RunAndReturn(run func(string, []byte, ...nats.PubOpt) (*nats.PubAck, error)) *JetStreamContextMock_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsync provides a mock function with given fields: subj, data, opts
func (_m *JetStreamContextMock) PublishAsync(subj string, data []byte, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 nats.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) (nats.PubAckFuture, error)); ok {
		return rf(subj, data, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) nats.PubAckFuture); ok {
		r0 = rf(subj, data, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...nats.PubOpt) error); ok {
		r1 = rf(subj, data, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_PublishAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsync'
type JetStreamContextMock_PublishAsync_Call struct {
	*mock.Call
}

// PublishAsync is a helper method to define mock.On call
//   - subj string
//   - data []byte
//   - opts ...nats.PubOpt
func (_e *JetStreamContextMock_Expecter) PublishAsync(subj interface{}, data interface{}, opts ...interface{}) *JetStreamContextMock_PublishAsync_Call {
	return &JetStreamContextMock_PublishAsync_Call{Call: _e.mock.On("PublishAsync",
		append([]interface{}{subj, data}, opts...)...)}
}

func (_c *JetStreamContextMock_PublishAsync_Call) Run(run func(subj string, data []byte, opts ...nats.PubOpt)) *JetStreamContextMock_PublishAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_PublishAsync_Call) Return(_a0 nats.PubAckFuture, _a1 error) *JetStreamContextMock_PublishAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_PublishAsync_Call) RunAndReturn(run func(string, []byte, ...nats.PubOpt) (nats.PubAckFuture, error)) *JetStreamContextMock_PublishAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncComplete provides a mock function with given fields:
func (_m *JetStreamContextMock) PublishAsyncComplete() <-chan struct{} {
	ret := _m.Called()

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// JetStreamContextMock_PublishAsyncComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncComplete'
type JetStreamContextMock_PublishAsyncComplete_Call struct {
	*mock.Call
}

// PublishAsyncComplete is a helper method to define mock.On call
func (_e *JetStreamContextMock_Expecter) PublishAsyncComplete() *JetStreamContextMock_PublishAsyncComplete_Call {
	return &JetStreamContextMock_PublishAsyncComplete_Call{Call: _e.mock.On("PublishAsyncComplete")}
}

func (_c *JetStreamContextMock_PublishAsyncComplete_Call) Run(run func()) *JetStreamContextMock_PublishAsyncComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContextMock_PublishAsyncComplete_Call) Return(_a0 <-chan struct{}) *JetStreamContextMock_PublishAsyncComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_PublishAsyncComplete_Call) RunAndReturn(run func() <-chan struct{}) *JetStreamContextMock_PublishAsyncComplete_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncPending provides a mock function with given fields:
func (_m *JetStreamContextMock) PublishAsyncPending() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// JetStreamContextMock_PublishAsyncPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncPending'
type JetStreamContextMock_PublishAsyncPending_Call struct {
	*mock.Call
}

// PublishAsyncPending is a helper method to define mock.On call
func (_e *JetStreamContextMock_Expecter) PublishAsyncPending() *JetStreamContextMock_PublishAsyncPending_Call {
	return &JetStreamContextMock_PublishAsyncPending_Call{Call: _e.mock.On("PublishAsyncPending")}
}

func (_c *JetStreamContextMock_PublishAsyncPending_Call) Run(run func()) *JetStreamContextMock_PublishAsyncPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContextMock_PublishAsyncPending_Call) Return(_a0 int) *JetStreamContextMock_PublishAsyncPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_PublishAsyncPending_Call) RunAndReturn(run func() int) *JetStreamContextMock_PublishAsyncPending_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: m, opts
func (_m *JetStreamContextMock) PublishMsg(m *nats.Msg, opts ...nats.PubOpt) (*nats.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, m)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) (*nats.PubAck, error)); ok {
		return rf(m, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) *nats.PubAck); ok {
		r0 = rf(m, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...nats.PubOpt) error); ok {
		r1 = rf(m, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type JetStreamContextMock_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - m *nats.Msg
//   - opts ...nats.PubOpt
func (_e *JetStreamContextMock_Expecter) PublishMsg(m interface{}, opts ...interface{}) *JetStreamContextMock_PublishMsg_Call {
	return &JetStreamContextMock_PublishMsg_Call{Call: _e.mock.On("PublishMsg",
		append([]interface{}{m}, opts...)...)}
}

func (_c *JetStreamContextMock_PublishMsg_Call) Run(run func(m *nats.Msg, opts ...nats.PubOpt)) *JetStreamContextMock_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_PublishMsg_Call) Return(_a0 *nats.PubAck, _a1 error) *JetStreamContextMock_PublishMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_PublishMsg_Call) RunAndReturn(run func(*nats.Msg, ...nats.PubOpt) (*nats.PubAck, error)) *JetStreamContextMock_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsgAsync provides a mock function with given fields: m, opts
func (_m *JetStreamContextMock) PublishMsgAsync(m *nats.Msg, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, m)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 nats.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) (nats.PubAckFuture, error)); ok {
		return rf(m, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) nats.PubAckFuture); ok {
		r0 = rf(m, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...nats.PubOpt) error); ok {
		r1 = rf(m, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_PublishMsgAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsgAsync'
type JetStreamContextMock_PublishMsgAsync_Call struct {
	*mock.Call
}

// PublishMsgAsync is a helper method to define mock.On call
//   - m *nats.Msg
//   - opts ...nats.PubOpt
func (_e *JetStreamContextMock_Expecter) PublishMsgAsync(m interface{}, opts ...interface{}) *JetStreamContextMock_PublishMsgAsync_Call {
	return &JetStreamContextMock_PublishMsgAsync_Call{Call: _e.mock.On("PublishMsgAsync",
		append([]interface{}{m}, opts...)...)}
}

func (_c *JetStreamContextMock_PublishMsgAsync_Call) Run(run func(m *nats.Msg, opts ...nats.PubOpt)) *JetStreamContextMock_PublishMsgAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_PublishMsgAsync_Call) Return(_a0 nats.PubAckFuture, _a1 error) *JetStreamContextMock_PublishMsgAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_PublishMsgAsync_Call) RunAndReturn(run func(*nats.Msg, ...nats.PubOpt) (nats.PubAckFuture, error)) *JetStreamContextMock_PublishMsgAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PullSubscribe provides a mock function with given fields: subj, durable, opts
func (_m *JetStreamContextMock) PullSubscribe(subj string, durable string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, durable)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, durable, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, durable, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, durable, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_PullSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PullSubscribe'
type JetStreamContextMock_PullSubscribe_Call struct {
	*mock.Call
}

// PullSubscribe is a helper method to define mock.On call
//   - subj string
//   - durable string
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) PullSubscribe(subj interface{}, durable interface{}, opts ...interface{}) *JetStreamContextMock_PullSubscribe_Call {
	return &JetStreamContextMock_PullSubscribe_Call{Call: _e.mock.On("PullSubscribe",
		append([]interface{}{subj, durable}, opts...)...)}
}

func (_c *JetStreamContextMock_PullSubscribe_Call) Run(run func(subj string, durable string, opts ...nats.SubOpt)) *JetStreamContextMock_PullSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_PullSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_PullSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_PullSubscribe_Call) RunAndReturn(run func(string, string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_PullSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeStream provides a mock function with given fields: name, opts
func (_m *JetStreamContextMock) PurgeStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_PurgeStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeStream'
type JetStreamContextMock_PurgeStream_Call struct {
	*mock.Call
}

// PurgeStream is a helper method to define mock.On call
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) PurgeStream(name interface{}, opts ...interface{}) *JetStreamContextMock_PurgeStream_Call {
	return &JetStreamContextMock_PurgeStream_Call{Call: _e.mock.On("PurgeStream",
		append([]interface{}{name}, opts...)...)}
}

func (_c *JetStreamContextMock_PurgeStream_Call) Run(run func(name string, opts ...nats.JSOpt)) *JetStreamContextMock_PurgeStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_PurgeStream_Call) Return(_a0 error) *JetStreamContextMock_PurgeStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_PurgeStream_Call) RunAndReturn(run func(string, ...nats.JSOpt) error) *JetStreamContextMock_PurgeStream_Call {
	_c.Call.Return(run)
	return _c
}

// QueueSubscribe provides a mock function with given fields: subj, queue, cb, opts
func (_m *JetStreamContextMock) QueueSubscribe(subj string, queue string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue, cb)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, cb, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, nats.MsgHandler, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, cb, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, nats.MsgHandler, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, cb, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_QueueSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueueSubscribe'
type JetStreamContextMock_QueueSubscribe_Call struct {
	*mock.Call
}

// QueueSubscribe is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - cb nats.MsgHandler
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) QueueSubscribe(subj interface{}, queue interface{}, cb interface{}, opts ...interface{}) *JetStreamContextMock_QueueSubscribe_Call {
	return &JetStreamContextMock_QueueSubscribe_Call{Call: _e.mock.On("QueueSubscribe",
		append([]interface{}{subj, queue, cb}, opts...)...)}
}

func (_c *JetStreamContextMock_QueueSubscribe_Call) Run(run func(subj string, queue string, cb nats.MsgHandler, opts ...nats.SubOpt)) *JetStreamContextMock_QueueSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(nats.MsgHandler), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_QueueSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_QueueSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_QueueSubscribe_Call) RunAndReturn(run func(string, string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_QueueSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// QueueSubscribeSync provides a mock function with given fields: subj, queue, opts
func (_m *JetStreamContextMock) QueueSubscribeSync(subj string, queue string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_QueueSubscribeSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueueSubscribeSync'
type JetStreamContextMock_QueueSubscribeSync_Call struct {
	*mock.Call
}

// QueueSubscribeSync is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) QueueSubscribeSync(subj interface{}, queue interface{}, opts ...interface{}) *JetStreamContextMock_QueueSubscribeSync_Call {
	return &JetStreamContextMock_QueueSubscribeSync_Call{Call: _e.mock.On("QueueSubscribeSync",
		append([]interface{}{subj, queue}, opts...)...)}
}

func (_c *JetStreamContextMock_QueueSubscribeSync_Call) Run(run func(subj string, queue string, opts ...nats.SubOpt)) *JetStreamContextMock_QueueSubscribeSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_QueueSubscribeSync_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_QueueSubscribeSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_QueueSubscribeSync_Call) RunAndReturn(run func(string, string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_QueueSubscribeSync_Call {
	_c.Call.Return(run)
	return _c
}

// SecureDeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContextMock) SecureDeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContextMock_SecureDeleteMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecureDeleteMsg'
type JetStreamContextMock_SecureDeleteMsg_Call struct {
	*mock.Call
}

// SecureDeleteMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) SecureDeleteMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContextMock_SecureDeleteMsg_Call {
	return &JetStreamContextMock_SecureDeleteMsg_Call{Call: _e.mock.On("SecureDeleteMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContextMock_SecureDeleteMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContextMock_SecureDeleteMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_SecureDeleteMsg_Call) Return(_a0 error) *JetStreamContextMock_SecureDeleteMsg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_SecureDeleteMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) error) *JetStreamContextMock_SecureDeleteMsg_Call {
	_c.Call.Return(run)
	return _c
}

// StreamInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamContextMock) StreamInfo(stream string, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(stream, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_StreamInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamInfo'
type JetStreamContextMock_StreamInfo_Call struct {
	*mock.Call
}

// StreamInfo is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) StreamInfo(stream interface{}, opts ...interface{}) *JetStreamContextMock_StreamInfo_Call {
	return &JetStreamContextMock_StreamInfo_Call{Call: _e.mock.On("StreamInfo",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContextMock_StreamInfo_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContextMock_StreamInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_StreamInfo_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContextMock_StreamInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_StreamInfo_Call) RunAndReturn(run func(string, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContextMock_StreamInfo_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNameBySubject provides a mock function with given fields: _a0, _a1
func (_m *JetStreamContextMock) StreamNameBySubject(_a0 string, _a1 ...nats.JSOpt) (string, error) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) (string, error)); ok {
		return rf(_a0, _a1...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) string); ok {
		r0 = rf(_a0, _a1...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.JSOpt) error); ok {
		r1 = rf(_a0, _a1...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_StreamNameBySubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNameBySubject'
type JetStreamContextMock_StreamNameBySubject_Call struct {
	*mock.Call
}

// StreamNameBySubject is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) StreamNameBySubject(_a0 interface{}, _a1 ...interface{}) *JetStreamContextMock_StreamNameBySubject_Call {
	return &JetStreamContextMock_StreamNameBySubject_Call{Call: _e.mock.On("StreamNameBySubject",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *JetStreamContextMock_StreamNameBySubject_Call) Run(run func(_a0 string, _a1 ...nats.JSOpt)) *JetStreamContextMock_StreamNameBySubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_StreamNameBySubject_Call) Return(_a0 string, _a1 error) *JetStreamContextMock_StreamNameBySubject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_StreamNameBySubject_Call) RunAndReturn(run func(string, ...nats.JSOpt) (string, error)) *JetStreamContextMock_StreamNameBySubject_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNames provides a mock function with given fields: opts
func (_m *JetStreamContextMock) StreamNames(opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan string); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContextMock_StreamNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNames'
type JetStreamContextMock_StreamNames_Call struct {
	*mock.Call
}

// StreamNames is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) StreamNames(opts ...interface{}) *JetStreamContextMock_StreamNames_Call {
	return &JetStreamContextMock_StreamNames_Call{Call: _e.mock.On("StreamNames",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_StreamNames_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContextMock_StreamNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_StreamNames_Call) Return(_a0 <-chan string) *JetStreamContextMock_StreamNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_StreamNames_Call) RunAndReturn(run func(...nats.JSOpt) <-chan string) *JetStreamContextMock_StreamNames_Call {
	_c.Call.Return(run)
	return _c
}

// Streams provides a mock function with given fields: opts
func (_m *JetStreamContextMock) Streams(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan *nats.StreamInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.StreamInfo)
		}
	}

	return r0
}

// JetStreamContextMock_Streams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Streams'
type JetStreamContextMock_Streams_Call struct {
	*mock.Call
}

// Streams is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) Streams(opts ...interface{}) *JetStreamContextMock_Streams_Call {
	return &JetStreamContextMock_Streams_Call{Call: _e.mock.On("Streams",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_Streams_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContextMock_Streams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_Streams_Call) Return(_a0 <-chan *nats.StreamInfo) *JetStreamContextMock_Streams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_Streams_Call) RunAndReturn(run func(...nats.JSOpt) <-chan *nats.StreamInfo) *JetStreamContextMock_Streams_Call {
	_c.Call.Return(run)
	return _c
}

// StreamsInfo provides a mock function with given fields: opts
func (_m *JetStreamContextMock) StreamsInfo(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan *nats.StreamInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.StreamInfo)
		}
	}

	return r0
}

// JetStreamContextMock_StreamsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamsInfo'
type JetStreamContextMock_StreamsInfo_Call struct {
	*mock.Call
}

// StreamsInfo is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) StreamsInfo(opts ...interface{}) *JetStreamContextMock_StreamsInfo_Call {
	return &JetStreamContextMock_StreamsInfo_Call{Call: _e.mock.On("StreamsInfo",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContextMock_StreamsInfo_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContextMock_StreamsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_StreamsInfo_Call) Return(_a0 <-chan *nats.StreamInfo) *JetStreamContextMock_StreamsInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContextMock_StreamsInfo_Call) RunAndReturn(run func(...nats.JSOpt) <-chan *nats.StreamInfo) *JetStreamContextMock_StreamsInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: subj, cb, opts
func (_m *JetStreamContextMock) Subscribe(subj string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, cb)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, cb, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, cb, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, nats.MsgHandler, ...nats.SubOpt) error); ok {
		r1 = rf(subj, cb, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type JetStreamContextMock_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - subj string
//   - cb nats.MsgHandler
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) Subscribe(subj interface{}, cb interface{}, opts ...interface{}) *JetStreamContextMock_Subscribe_Call {
	return &JetStreamContextMock_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{subj, cb}, opts...)...)}
}

func (_c *JetStreamContextMock_Subscribe_Call) Run(run func(subj string, cb nats.MsgHandler, opts ...nats.SubOpt)) *JetStreamContextMock_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(nats.MsgHandler), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_Subscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_Subscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_Subscribe_Call) RunAndReturn(run func(string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeSync provides a mock function with given fields: subj, opts
func (_m *JetStreamContextMock) SubscribeSync(subj string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_SubscribeSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeSync'
type JetStreamContextMock_SubscribeSync_Call struct {
	*mock.Call
}

// SubscribeSync is a helper method to define mock.On call
//   - subj string
//   - opts ...nats.SubOpt
func (_e *JetStreamContextMock_Expecter) SubscribeSync(subj interface{}, opts ...interface{}) *JetStreamContextMock_SubscribeSync_Call {
	return &JetStreamContextMock_SubscribeSync_Call{Call: _e.mock.On("SubscribeSync",
		append([]interface{}{subj}, opts...)...)}
}

func (_c *JetStreamContextMock_SubscribeSync_Call) Run(run func(subj string, opts ...nats.SubOpt)) *JetStreamContextMock_SubscribeSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_SubscribeSync_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContextMock_SubscribeSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_SubscribeSync_Call) RunAndReturn(run func(string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContextMock_SubscribeSync_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamContextMock) UpdateConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_UpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConsumer'
type JetStreamContextMock_UpdateConsumer_Call struct {
	*mock.Call
}

// UpdateConsumer is a helper method to define mock.On call
//   - stream string
//   - cfg *nats.ConsumerConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) UpdateConsumer(stream interface{}, cfg interface{}, opts ...interface{}) *JetStreamContextMock_UpdateConsumer_Call {
	return &JetStreamContextMock_UpdateConsumer_Call{Call: _e.mock.On("UpdateConsumer",
		append([]interface{}{stream, cfg}, opts...)...)}
}

func (_c *JetStreamContextMock_UpdateConsumer_Call) Run(run func(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt)) *JetStreamContextMock_UpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(*nats.ConsumerConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_UpdateConsumer_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContextMock_UpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_UpdateConsumer_Call) RunAndReturn(run func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContextMock_UpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamContextMock) UpdateStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContextMock_UpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStream'
type JetStreamContextMock_UpdateStream_Call struct {
	*mock.Call
}

// UpdateStream is a helper method to define mock.On call
//   - cfg *nats.StreamConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContextMock_Expecter) UpdateStream(cfg interface{}, opts ...interface{}) *JetStreamContextMock_UpdateStream_Call {
	return &JetStreamContextMock_UpdateStream_Call{Call: _e.mock.On("UpdateStream",
		append([]interface{}{cfg}, opts...)...)}
}

func (_c *JetStreamContextMock_UpdateStream_Call) Run(run func(cfg *nats.StreamConfig, opts ...nats.JSOpt)) *JetStreamContextMock_UpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(*nats.StreamConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContextMock_UpdateStream_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContextMock_UpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContextMock_UpdateStream_Call) RunAndReturn(run func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContextMock_UpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// NewJetStreamContextMock creates a new instance of JetStreamContextMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewJetStreamContextMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *JetStreamContextMock {
	mock := &JetStreamContextMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
